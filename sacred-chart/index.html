<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="apple-mobile-web-app-title" content="Sacred Chart">
  <meta name="theme-color" content="#115e59">
  <title>Scrubs Prediction Game - The Sacred Chart</title>
  
  <link rel="apple-touch-icon" href="https://git-out-of-town.github.io/repository-1/sacred-chart/apple-touch-icon.png?v=3">
  <link rel="apple-touch-icon" sizes="180x180" href="https://git-out-of-town.github.io/repository-1/sacred-chart/apple-touch-icon-180x180.png?v=3">
  <link rel="apple-touch-icon" sizes="167x167" href="https://git-out-of-town.github.io/repository-1/sacred-chart/apple-touch-icon-167x167.png?v=3">
  <link rel="apple-touch-icon" sizes="152x152" href="https://git-out-of-town.github.io/repository-1/sacred-chart/apple-touch-icon-152x152.png?v=3">
  <link rel="apple-touch-icon" sizes="192x192" href="https://git-out-of-town.github.io/repository-1/sacred-chart/icon-192.png?v=3">
  <link rel="manifest" href="manifest.json">
  
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  
  <style>
    body {
      margin: 0;
      padding: 0;
      overscroll-behavior: none;
    }
  </style>
</head>
<body>
  <div id="root"></div>
  
  <script type="text/babel">
    const { useState, useEffect } = React;

    // Encoded default data (Round 1 baseline)
    const _d = 'eyJwbGF5ZXJzIjp7InBsYXllcjEiOnsibmFtZSI6IkplYW4iLCJ0b3RhbFBvaW50cyI6NzR9LCJwbGF5ZXIyIjp7Im5hbWUiOiJFZCIsInRvdGFsUG9pbnRzIjo0Mn19LCJoaXN0b3J5IjpbXSwic2NvcmVzIjpbWzIsOCwzLDJdLFsyLDEwLDAsMV0sWzIsMTEsMiwxXSxbMiwxMiwwLDBdLFsyLDEzLDEsMV0sWzIsMTQsMiwwXSxbMiwxNSwwLDJdLFsyLDE2LDAsMV0sWzIsMTcsMSwwXSxbMiwxOCwxLDBdLFsyLDE5LDIsM10sWzIsMjAsMCwwXSxbMiwyMSwxLDBdLFsyLDIyLDIsMV0sWzMsMSwzLDBdLFszLDQsMCwxXSxbMyw2LDEsMV0sWzMsNywxLDBdLFszLDgsMiwxXSxbMyw5LDAsMV0sWzMsMTAsMSwwXSxbMywxMSwzLDFdLFszLDEyLDAsMV0sWzMsMTMsMiwxXSxbMywxNCwxLDBdLFszLDE3LDEsMF0sWzMsMTgsMywwXSxbMywxOSwyLDFdLFszLDIwLDUsMF0sWzMsMjEsMSwxXSxbMywyMiwyLDFdLFs0LDEsMSwyXSxbNCwyLDAsMV0sWzQsNCwxLDBdLFs0LDUsMywxXSxbNCw2LDMsMV0sWzQsNywzLDJdLFs0LDgsMSwxXSxbNCw5LDAsMl0sWzQsMTAsMiw0XSxbNCwxMSwxLDJdLFs0LDEyLDIsMF0sWzQsMTMsNCwxXSxbNCwxNCwyLDFdLFs0LDE1LDQsMF0sWzQsMTYsMiwxXSxbNCwxOCwxLDFdLFs0LDE5LDEsMF1dfQ==';

    const getDefaultData = () => {
      try {
        const decoded = JSON.parse(atob(_d));
        const history = [];
        const p1Name = decoded.players.player1.name;
        const p2Name = decoded.players.player2.name;
        decoded.scores.forEach(([s, e, p1, p2]) => {
          for (let i = 0; i < p1; i++) {
            history.push({ season: s, episode: e, predictor: p1Name, correct: true, winner: p1Name, timestamp: new Date(2024, 0, s, e, i).toISOString() });
          }
          for (let i = 0; i < p2; i++) {
            history.push({ season: s, episode: e, predictor: p2Name, correct: true, winner: p2Name, timestamp: new Date(2024, 0, s, e, 30 + i).toISOString() });
          }
        });
        return { players: decoded.players, history };
      } catch (e) { return null; }
    };

    function PredictionGame() {
      const [gameData, setGameData] = useState(null);
      const [loading, setLoading] = useState(true);
      const [currentSeason, setCurrentSeason] = useState(1);
      const [currentEpisode, setCurrentEpisode] = useState(1);
      const [showSetup, setShowSetup] = useState(false);
      const [player1Input, setPlayer1Input] = useState('');
      const [player2Input, setPlayer2Input] = useState('');
      const [lastAction, setLastAction] = useState(null);
      const [showUndo, setShowUndo] = useState(false);

      useEffect(() => {
        loadData();
      }, []);

      // Auto-hide undo after 5 seconds
      useEffect(() => {
        if (showUndo) {
          const timer = setTimeout(() => setShowUndo(false), 5000);
          return () => clearTimeout(timer);
        }
      }, [showUndo]);

      const setNextEpisode = (data) => {
        if (data && data.history && data.history.length > 0) {
          // Find the most recent episode (highest season, then highest episode)
          let maxSeason = 1, maxEpisode = 0;
          data.history.forEach(h => {
            if (h.season > maxSeason || (h.season === maxSeason && h.episode > maxEpisode)) {
              maxSeason = h.season;
              maxEpisode = h.episode;
            }
          });
          // Set to next episode
          setCurrentSeason(maxSeason);
          setCurrentEpisode(maxEpisode + 1);
        }
      };

      const loadData = () => {
        try {
          const saved = localStorage.getItem('sacred-chart-data');
          if (saved) {
            const parsed = JSON.parse(saved);
            setGameData(parsed);
            setNextEpisode(parsed);
          } else {
            // No saved data - load embedded defaults
            const defaults = getDefaultData();
            if (defaults) {
              saveData(defaults);
              setNextEpisode(defaults);
            } else {
              setShowSetup(true);
            }
          }
        } catch (e) {
          setShowSetup(true);
        }
        setLoading(false);
      };

      const startGame = () => {
        if (!player1Input.trim() || !player2Input.trim()) return;
        const newData = {
          players: {
            player1: { name: player1Input.trim(), totalPoints: 0 },
            player2: { name: player2Input.trim(), totalPoints: 0 }
          },
          history: []
        };
        saveData(newData);
        setShowSetup(false);
      };

      const saveData = (newData) => {
        setGameData(newData);
        try {
          localStorage.setItem('sacred-chart-data', JSON.stringify(newData));
        } catch (e) {
          console.error('Failed to save:', e);
        }
      };

      const awardPoint = (player, correct) => {
        const winner = correct ? player : (player === 'player1' ? 'player2' : 'player1');
        
        // Store current state for undo
        setLastAction(JSON.parse(JSON.stringify(gameData)));
        setShowUndo(true);

        const newData = {
          ...gameData,
          players: {
            ...gameData.players,
            [winner]: {
              ...gameData.players[winner],
              totalPoints: gameData.players[winner].totalPoints + 1
            }
          },
          history: [
            {
              season: currentSeason,
              episode: currentEpisode,
              predictor: gameData.players[player].name,
              correct,
              winner: gameData.players[winner].name,
              timestamp: new Date().toISOString()
            },
            ...gameData.history
          ]
        };
        saveData(newData);
      };

      const undoLastAction = () => {
        if (lastAction) {
          saveData(lastAction);
          setLastAction(null);
          setShowUndo(false);
        }
      };

      const manualAdjust = (player, delta) => {
        const playerName = gameData.players[player].name;
        
        if (delta === 1) {
          // Add a point: create a history entry for this episode
          const newData = {
            ...gameData,
            players: {
              ...gameData.players,
              [player]: {
                ...gameData.players[player],
                totalPoints: gameData.players[player].totalPoints + 1
              }
            },
            history: [
              {
                season: currentSeason,
                episode: currentEpisode,
                predictor: playerName,
                correct: true,
                winner: playerName,
                timestamp: new Date().toISOString(),
                manual: true
              },
              ...gameData.history
            ]
          };
          saveData(newData);
        } else if (delta === -1) {
          // Remove a point: find the most recent history entry for this player in this episode
          const idx = gameData.history.findIndex(
            h => h.season === currentSeason && h.episode === currentEpisode && h.winner === playerName
          );
          if (idx === -1) return; // No points to remove
          
          const newHistory = [...gameData.history];
          newHistory.splice(idx, 1);
          
          const newData = {
            ...gameData,
            players: {
              ...gameData.players,
              [player]: {
                ...gameData.players[player],
                totalPoints: Math.max(0, gameData.players[player].totalPoints - 1)
              }
            },
            history: newHistory
          };
          saveData(newData);
        }
      };

      const resetScores = () => {
        if (confirm('Reset all scores and history? Player names will be kept.')) {
          const newData = {
            players: {
              player1: { name: gameData.players.player1.name, totalPoints: 0 },
              player2: { name: gameData.players.player2.name, totalPoints: 0 }
            },
            history: []
          };
          saveData(newData);
          setCurrentSeason(1);
          setCurrentEpisode(1);
          setLastAction(null);
          setShowUndo(false);
        }
      };

      const resetEverything = () => {
        if (confirm('Reset EVERYTHING including player names?')) {
          localStorage.removeItem('sacred-chart-data');
          setGameData(null);
          setShowSetup(true);
          setPlayer1Input('');
          setPlayer2Input('');
          setCurrentSeason(1);
          setCurrentEpisode(1);
          setLastAction(null);
          setShowUndo(false);
        }
      };

      const exportData = () => {
        const data = localStorage.getItem('sacred-chart-data');
        if (data) {
          navigator.clipboard.writeText(data).then(() => {
            alert('Backup copied to clipboard! Paste it into Notes to save.');
          }).catch(() => {
            // Fallback for iOS
            const ta = document.createElement('textarea');
            ta.value = data;
            document.body.appendChild(ta);
            ta.select();
            document.execCommand('copy');
            document.body.removeChild(ta);
            alert('Backup copied! Paste it into Notes to save.');
          });
        }
      };

      if (loading) {
        return (
          <div className="min-h-screen bg-teal-900 flex items-center justify-center">
            <div className="text-white text-xl">Loading...</div>
          </div>
        );
      }

      if (showSetup) {
        return (
          <div className="min-h-screen bg-gradient-to-b from-teal-800 to-teal-900 p-4 flex items-center justify-center">
            <div className="max-w-md w-full">
              <div className="text-center mb-8">
                <h1 className="text-2xl font-bold text-white mb-1">üè• Scrubs Prediction Game</h1>
                <p className="text-teal-200 text-sm">The Sacred Chart</p>
              </div>
              <div className="bg-white rounded-xl p-6 shadow-lg">
                <h2 className="text-lg font-semibold text-gray-700 text-center mb-4">Enter Player Names</h2>
                <div className="space-y-4">
                  <div>
                    <label className="text-sm text-gray-500 block mb-1">Player 1</label>
                    <input
                      type="text"
                      value={player1Input}
                      onChange={(e) => setPlayer1Input(e.target.value)}
                      className="w-full px-4 py-3 border border-gray-200 rounded-lg text-gray-700 focus:outline-none focus:border-teal-500"
                      placeholder="Enter name"
                      maxLength={15}
                    />
                  </div>
                  <div>
                    <label className="text-sm text-gray-500 block mb-1">Player 2</label>
                    <input
                      type="text"
                      value={player2Input}
                      onChange={(e) => setPlayer2Input(e.target.value)}
                      className="w-full px-4 py-3 border border-gray-200 rounded-lg text-gray-700 focus:outline-none focus:border-teal-500"
                      placeholder="Enter name"
                      maxLength={15}
                    />
                  </div>
                  <button
                    onClick={startGame}
                    disabled={!player1Input.trim() || !player2Input.trim()}
                    className="w-full py-3 bg-teal-600 hover:bg-teal-700 disabled:bg-gray-300 text-white rounded-lg font-bold transition-colors"
                  >
                    Start Playing!
                  </button>
                </div>
              </div>
            </div>
          </div>
        );
      }

      const p1 = gameData.players.player1;
      const p2 = gameData.players.player2;

      // Episode scores
      const episodeEntries = gameData.history.filter(h => h.season === currentSeason && h.episode === currentEpisode);
      const p1EpisodePts = episodeEntries.filter(h => h.winner === p1.name).length;
      const p2EpisodePts = episodeEntries.filter(h => h.winner === p2.name).length;
      const episodeLeader = p1EpisodePts > p2EpisodePts ? p1.name : p2EpisodePts > p1EpisodePts ? p2.name : 'Tied';

      return (
        <div className="min-h-screen bg-gradient-to-b from-teal-800 to-teal-900 p-4">
          <div className="max-w-md mx-auto">
            {/* Header */}
            <div className="text-center mb-6">
              <h1 className="text-2xl font-bold text-white mb-1">üè• Scrubs Prediction Game</h1>
              <p className="text-teal-200 text-sm">The Sacred Chart</p>
            </div>

            {/* Episode Selector */}
            <div className="bg-white/10 rounded-xl p-4 mb-4">
              <div className="flex items-center justify-center gap-4">
                <div className="text-center">
                  <label className="text-teal-200 text-xs block mb-1">Season</label>
                  <div className="flex items-center gap-2">
                    <button 
                      onClick={() => setCurrentSeason(Math.max(1, currentSeason - 1))}
                      className="w-8 h-8 bg-teal-600 text-white rounded-lg font-bold"
                    >-</button>
                    <span className="text-white text-xl font-bold w-8 text-center">{currentSeason}</span>
                    <button 
                      onClick={() => setCurrentSeason(Math.min(9, currentSeason + 1))}
                      className="w-8 h-8 bg-teal-600 text-white rounded-lg font-bold"
                    >+</button>
                  </div>
                </div>
                <div className="text-3xl text-teal-400">:</div>
                <div className="text-center">
                  <label className="text-teal-200 text-xs block mb-1">Episode</label>
                  <div className="flex items-center gap-2">
                    <button 
                      onClick={() => setCurrentEpisode(Math.max(1, currentEpisode - 1))}
                      className="w-8 h-8 bg-teal-600 text-white rounded-lg font-bold"
                    >-</button>
                    <span className="text-white text-xl font-bold w-8 text-center">{currentEpisode}</span>
                    <button 
                      onClick={() => setCurrentEpisode(currentEpisode + 1)}
                      className="w-8 h-8 bg-teal-600 text-white rounded-lg font-bold"
                    >+</button>
                  </div>
                </div>
              </div>
            </div>

            {/* Episode Scoreboard */}
            <div className="bg-white rounded-xl p-4 mb-4 shadow-lg">
              <div className="text-center text-xs text-gray-400 mb-2">S{currentSeason} E{currentEpisode}</div>
              <div className="flex justify-around items-center">
                <div className="text-center">
                  <div className="text-4xl font-bold text-teal-700">{p1EpisodePts}</div>
                  <div className="text-lg font-semibold text-gray-700">{p1.name}</div>
                  <div className="flex items-center justify-center gap-2 mt-1">
                    <button
                      onClick={() => manualAdjust('player1', -1)}
                      className="w-7 h-7 bg-gray-200 text-gray-600 rounded-full font-bold text-sm"
                    >-</button>
                    <button
                      onClick={() => manualAdjust('player1', 1)}
                      className="w-7 h-7 bg-gray-200 text-gray-600 rounded-full font-bold text-sm"
                    >+</button>
                  </div>
                </div>
                <div className="text-center">
                  <div className="text-xs px-3 py-1 bg-teal-100 text-teal-700 rounded-full font-medium">
                    {episodeLeader === 'Tied' ? 'ü§ù Tied!' : `üëë ${episodeLeader} leads`}
                  </div>
                </div>
                <div className="text-center">
                  <div className="text-4xl font-bold text-teal-700">{p2EpisodePts}</div>
                  <div className="text-lg font-semibold text-gray-700">{p2.name}</div>
                  <div className="flex items-center justify-center gap-2 mt-1">
                    <button
                      onClick={() => manualAdjust('player2', -1)}
                      className="w-7 h-7 bg-gray-200 text-gray-600 rounded-full font-bold text-sm"
                    >-</button>
                    <button
                      onClick={() => manualAdjust('player2', 1)}
                      className="w-7 h-7 bg-gray-200 text-gray-600 rounded-full font-bold text-sm"
                    >+</button>
                  </div>
                </div>
              </div>
            </div>




            {/* Prediction Buttons */}
            <div className="grid grid-cols-2 gap-4 mb-4">
              <div className="bg-white/10 rounded-xl p-3">
                <div className="text-white text-center font-semibold mb-2">{p1.name} predicts...</div>
                <button
                  onClick={() => awardPoint('player1', true)}
                  className="w-full py-3 bg-green-500 hover:bg-green-600 text-white rounded-lg font-bold mb-2 transition-colors"
                >
                  ‚úì Correct!
                </button>
                <button
                  onClick={() => awardPoint('player1', false)}
                  className="w-full py-3 bg-red-400 hover:bg-red-500 text-white rounded-lg font-bold transition-colors"
                >
                  ‚úó Wrong
                </button>
              </div>

              <div className="bg-white/10 rounded-xl p-3">
                <div className="text-white text-center font-semibold mb-2">{p2.name} predicts...</div>
                <button
                  onClick={() => awardPoint('player2', true)}
                  className="w-full py-3 bg-green-500 hover:bg-green-600 text-white rounded-lg font-bold mb-2 transition-colors"
                >
                  ‚úì Correct!
                </button>
                <button
                  onClick={() => awardPoint('player2', false)}
                  className="w-full py-3 bg-red-400 hover:bg-red-500 text-white rounded-lg font-bold transition-colors"
                >
                  ‚úó Wrong
                </button>
              </div>
            </div>

            {/* Leaderboard */}
            <div className="bg-white/10 rounded-xl p-4">
              <h2 className="text-white font-semibold mb-3">Leaderboard</h2>
              {gameData.history.length === 0 ? (
                <p className="text-teal-200 text-sm text-center py-4">No predictions yet!</p>
              ) : (
                <div className="space-y-2 max-h-56 overflow-y-auto">
                  {[...new Set(gameData.history.map(h => h.season))].sort((a, b) => a - b).map(season => {
                    const seasonEntries = gameData.history.filter(h => h.season === season);
                    const p1SeasonPts = seasonEntries.filter(h => h.winner === p1.name).length;
                    const p2SeasonPts = seasonEntries.filter(h => h.winner === p2.name).length;
                    const seasonLeader = p1SeasonPts > p2SeasonPts ? 'üëë' : p2SeasonPts > p1SeasonPts ? 'üëë' : 'ü§ù';
                    return (
                      <div key={season} className="flex justify-between items-center text-sm bg-white/5 rounded-lg px-3 py-2">
                        <span className="text-teal-200 font-medium">Season {season}</span>
                        <div className="flex items-center gap-4">
                          <span className={`text-white ${p1SeasonPts > p2SeasonPts ? 'font-bold' : ''}`}>
                            {p1SeasonPts > p2SeasonPts && seasonLeader} {p1.name}: {p1SeasonPts}
                          </span>
                          <span className={`text-white ${p2SeasonPts > p1SeasonPts ? 'font-bold' : ''}`}>
                            {p2.name}: {p2SeasonPts} {p2SeasonPts > p1SeasonPts && seasonLeader}
                          </span>
                          {p1SeasonPts === p2SeasonPts && <span>{seasonLeader}</span>}
                        </div>
                      </div>
                    );
                  })}
                  {/* All-Time Tally */}
                  <div className="flex justify-between items-center text-sm bg-teal-600/40 rounded-lg px-3 py-2 mt-2 border border-teal-400/30">
                    <span className="text-white font-bold">All-Time</span>
                    <div className="flex items-center gap-4">
                      <span className={`text-white ${p1.totalPoints > p2.totalPoints ? 'font-bold' : ''}`}>
                        {p1.totalPoints > p2.totalPoints && 'üëë'} {p1.name}: {p1.totalPoints}
                      </span>
                      <span className={`text-white ${p2.totalPoints > p1.totalPoints ? 'font-bold' : ''}`}>
                        {p2.name}: {p2.totalPoints} {p2.totalPoints > p1.totalPoints && 'üëë'}
                      </span>
                      {p1.totalPoints === p2.totalPoints && <span>ü§ù</span>}
                    </div>
                  </div>
                </div>
              )}
            </div>

            {/* Footer Actions */}
            <div className="flex justify-center gap-4 mt-4">
              <button
                onClick={exportData}
                className="text-xs text-amber-300 hover:text-white"
              >
                Export
              </button>
              <button
                onClick={resetScores}
                className="text-xs text-teal-300 hover:text-white"
              >
                Reset Scores
              </button>
              <button
                onClick={resetEverything}
                className="text-xs text-red-300 hover:text-white"
              >
                Reset All
              </button>
            </div>
          </div>
        </div>
      );
    }

    ReactDOM.createRoot(document.getElementById('root')).render(<PredictionGame />);
  </script>
</body>
</html>
